(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.Libp2PInterface = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var Libp2PInterface=(()=>{var n=Object.defineProperty;var A=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var h=Object.prototype.hasOwnProperty;var L=(e,t)=>{for(var o in t)n(e,o,{get:t[o],enumerable:!0})},_=(e,t,o,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of y(t))!h.call(e,s)&&s!==o&&n(e,s,{get:()=>t[s],enumerable:!(r=A(t,s))||r.enumerable});return e};var g=e=>_(n({},"__esModule",{value:!0}),e);var K={};L(K,{AbortError:()=>c,CodeError:()=>a,CustomEvent:()=>R,ERR_INVALID_MESSAGE:()=>G,ERR_INVALID_PARAMETERS:()=>B,ERR_NOT_FOUND:()=>F,ERR_TIMEOUT:()=>k,Ed25519:()=>w,FaultTolerance:()=>i,InvalidCryptoExchangeError:()=>x,KEEP_ALIVE:()=>O,RSA:()=>N,StrictNoSign:()=>U,StrictSign:()=>C,TopicValidatorResult:()=>p,TypedEventEmitter:()=>f,UnexpectedPeerError:()=>l,connectionSymbol:()=>E,contentRoutingSymbol:()=>v,isConnection:()=>I,isPeerId:()=>M,isStartable:()=>m,isTransport:()=>V,peerDiscoverySymbol:()=>P,peerIdSymbol:()=>S,peerRoutingSymbol:()=>D,secp256k1:()=>T,setMaxListeners:()=>j,start:()=>X,stop:()=>H,transportSymbol:()=>d});var E=Symbol.for("@libp2p/connection");function I(e){return e!=null&&!!e[E]}var v=Symbol.for("@libp2p/content-routing");var w="Ed25519",N="RSA",T="secp256k1";var P=Symbol.for("@libp2p/peer-discovery");var S=Symbol.for("@libp2p/peer-id");function M(e){return e!=null&&!!e[S]}var D=Symbol.for("@libp2p/peer-routing");var O="keep-alive";var C="StrictSign",U="StrictNoSign",p;(function(e){e.Accept="accept",e.Ignore="ignore",e.Reject="reject"})(p||(p={}));var d=Symbol.for("@libp2p/transport");function V(e){return e!=null&&!!e[d]}var i;(function(e){e[e.FATAL_ALL=0]="FATAL_ALL",e[e.NO_FATAL=1]="NO_FATAL"})(i||(i={}));var c=class e extends Error{code;type;constructor(t="The operation was aborted"){super(t),this.code=e.code,this.type=e.type}static code="ABORT_ERR";static type="aborted"},a=class extends Error{code;props;constructor(t,o,r){super(t),this.code=o,this.name=r?.name??"CodeError",this.props=r??{}}},l=class e extends Error{code;constructor(t="Unexpected Peer"){super(t),this.code=e.code}static code="ERR_UNEXPECTED_PEER"},x=class e extends Error{code;constructor(t="Invalid crypto exchange"){super(t),this.code=e.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"},k="ERR_TIMEOUT",B="ERR_INVALID_PARAMETERS",F="ERR_NOT_FOUND",G="ERR_INVALID_MESSAGE";var f=class extends EventTarget{#t=new Map;listenerCount(t){let o=this.#t.get(t);return o==null?0:o.length}addEventListener(t,o,r){super.addEventListener(t,o,r);let s=this.#t.get(t);s==null&&(s=[],this.#t.set(t,s)),s.push({callback:o,once:(r!==!0&&r!==!1&&r?.once)??!1})}removeEventListener(t,o,r){super.removeEventListener(t.toString(),o??null,r);let s=this.#t.get(t);s!=null&&(s=s.filter(({callback:b})=>b!==o),this.#t.set(t,s))}dispatchEvent(t){let o=super.dispatchEvent(t),r=this.#t.get(t.type);return r==null||(r=r.filter(({once:s})=>!s),this.#t.set(t.type,r)),o}safeDispatchEvent(t,o){return this.dispatchEvent(new R(t,o))}},u=class extends Event{detail;constructor(t,o){super(t,o),this.detail=o?.detail}},R=globalThis.CustomEvent??u,j=(e,...t)=>{try{[...t]}catch{}};function m(e){return e!=null&&typeof e.start=="function"&&typeof e.stop=="function"}async function X(...e){let t=[];for(let o of e)m(o)&&t.push(o);await Promise.all(t.map(async o=>{o.beforeStart!=null&&await o.beforeStart()})),await Promise.all(t.map(async o=>{await o.start()})),await Promise.all(t.map(async o=>{o.afterStart!=null&&await o.afterStart()}))}async function H(...e){let t=[];for(let o of e)m(o)&&t.push(o);await Promise.all(t.map(async o=>{o.beforeStop!=null&&await o.beforeStop()})),await Promise.all(t.map(async o=>{await o.stop()})),await Promise.all(t.map(async o=>{o.afterStop!=null&&await o.afterStop()}))}return g(K);})();
return Libp2PInterface}));
